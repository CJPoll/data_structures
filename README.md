This project is a personal one, intended to increase my understanding of data
structures and the algorithms that act on them.

The basic idea is to implement each of the common data structures; determine the
worst, average, and best case time complexity for insertion, deletion, and
lookup of values for each; and determine the worst, average, and best case time
complexity for the algorithms that act upon them (particularly sorting
algorithms).

I'll implement each data structure in order:

1. Ruby
1. Objective-C
1. Java
1. Erlang
1. C++

I'll implement each data structure twice in each language,
* Once using standard libraries for the language (Hashes in Ruby, NSDictionary
  in Objective-C, etc.)
* A second time using only language primitives (No libraries)(Arrays are
  acceptable)

[A list of Data Structures](http://en.wikipedia.org/wiki/List_of_data_structures)
to implement:
* Linear Data Structures
	* Arrays
		1. Array (Usually a language primitive - not going to implement myself)
		1. Bidirectional Map (Started implementing, but decided to learn more
		   about structures to back it first)
		1. Bit array
		1. Bit field
		1. Bit board
		1. Bit map
		1. Circular buffer
		1. Control table
		1. Image
		1. Dynamic Array (Vector or ArrayList)
		1. Gap Buffer
		1. Hashed array tree
		1. Heightmap
		1. Lookup table
		1. Matrix
		1. Parallel array
		1. Sorted array
		1. Sparse array
		1. Sparse matrix
		1. Lliffe vector
		1. Variable-length array
	* Lists
		1. Double linked list
		1. Linked list				# Check! (Still need to add error handling)
		1. Self-organizing list
		1. Skip list
		1. Unrolled linked list
		1. Vlist
		1. Xor linked list
		1. Zipper
		1. Doubly connected edge list
		1. Difference list
* Trees
	* Binary Trees
		1. AA tree
		1. AVL tree
		1. Binary search tree
		1. Binary tree
		1. Cartesian tree
		1. Pagoda
		1. Randomized binary search tree
		1. Red-black tree
		1. Rope
		1. Scapegoat tree
		1. Self-balancing binary search tree
		1. Splay tree
		1. T-tree
		1. Tango tree
		1. Threaded binary tree
		1. Top tree
		1. Treap
		1. Weight-balanced tree
	* B-trees
		1. B-tree
		1. B+ tree
		1. B*-tree
		1. Dancing tree
		1. 2-3 tree
		1. 2-3-4 tree
		1. Queap
		1. Fusion tree
		1. Bx-tree
	* Heaps
		1. Heap
		1. Binary heap
		1. Binomial heap
		1. Fibonacci heap
			* AF-heap
		1. 2-3 heap
		1. Soft heap
		1. Pairing heap
		1. Leftist heap
		1. Treap
		1. Beap
		1. Skew heap
		1. Ternary heap
		1. D-ary heap
	* Multiway Trees
		1. Ternary tree
		1. K-ary tree
		1. And-Or tree
		1. (a,b)-tree
		1. Link/cut tree
		1. SPQR-tree
		1. Spaghetti stack
		1. Disjoint-set data structure
		1. Fusion tree
		1. Enfilade
		1. Exponential tree
		1. Fenwick tree
		1. Van Emde Boas tree
	* Trees 
		1. Tree
		1. Radix tree
		1. Suffix tree
		1. Suffix array
		1. Compressed suffix array
		1. FM-index
		1. Generalized suffix tree
		1. B-tree
		1. Judy array
		1. Ctree
	* Space partitioning trees
		1. Segment tree
		1. Interval tree
		1. Range tree
		1. Bin
		1. Kd-tree
		1. Implicit kd-tree
		1. Min/max kd-tree
		1. Adaptive kd-tree
		1. Quadtree
		1. Octree
		1. Linear octree
		1. Z-order
		1. UB-tree
		1. R-tree
		1. R+ tree
		1. R* tree
		1. Hilbert R-tree
		1. X-tree
		1. Metric tree
		1. Cover tree
		1. M-tree
		1. VP-tree
		1. BK-tree
		1. Bounding interval hierarchy
		1. BSP tree
		1. Rapidly exploring random tree
	* Application Specific Trees
		1. Abstract syntax tree
		1. Parse tree
		1. Decision tree
		1. Alternating decision tree
		1. Minimax tree
		1. Expectiminimax tree
		1. Finger tree
		1. Expression tree
* Hashes
	1. Bloom filter
	1. Count min sketch
	1. Distributed hash table
	1. Double hashing
	1. Dynamic perfect hash table
	1. Hash array mapped trie
	1. Hash list
	1. Hash table
	1. Hash tree
	1. Hash trie
	1. Koorde
	1. Prefix hash tree
	1. Rolling hash
	1. MinHash
* Graphs
	1. Graph
	1. Adjacency list
	1. Adjacency matrix
	1. Graph-structured stack
	1. Scene graph
	1. Binary decision diagram
	1. Zero supressed decision diagram
	1. And-inverter graph
	1. Directed graph
	1. Directed acyclic graph
	1. Propositional directed acyclic graph
	1. Multigraph
	1. Hypergraph
* Other
	1. Lightmap
	1. Winged edge
	1. Doubly connected edge list
	1. Quad-edge
	1. Routing table
	1. Symbol table
